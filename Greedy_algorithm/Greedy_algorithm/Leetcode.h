#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>
#include<stdbool.h>

// 贪心算法思想：依据问题的逻辑不断找到局部最优解法，并依次进行递推解决问题。而不用思考回溯和动态规划的问题

// 1.柠檬水找零
//在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
//
//每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
//
//注意，一开始你手头没有任何零钱。
//
//给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

bool lemonadeChange(int* bills, int billsSize);

//由于顾客只可能给你三个面值的钞票，而且我们一开始没有任何钞票，因此我们拥有的钞票面值只可能是 5 美元，10 美元和 20 美元三种。基于此，我们可以进行如下的分类讨论。
//
//5 美元，由于柠檬水的价格也为 5 美元，因此我们直接收下即可。
//
//10 美元，我们需要找回 5 美元，如果没有 5 美元面值的钞票，则无法正确找零。
//
//20 美元，我们需要找回 15 美元，此时有两种组合方式，一种是一张 10 美元和 5 美元的钞票，一种是 3 张 5 美元的钞票，如果两种组合方式都没有，则无法正确找零。
//
//当可以正确找零时，两种找零的方式中我们更倾向于第一种，即如果存在 5 美元和 10 美元，我们就按第一种方式找零。
//否则按第二种方式找零，因为需要使用 5 美元的找零场景会比需要使用 10 美元的找零场景多，我们需要尽可能保留 5 美元的钞票。
//
//基于此，我们维护两个变量 five 和 ten 表示当前手中拥有的 5 美元和 10 美元钞票的张数，从前往后遍历数组分类讨论即可。